from typing import Optional, List, Any, Dict

import attr
import numpy as np
import scipy.sparse as sp
from recsys_framework.Recommenders.BaseRecommender import BaseRecommender
from recsys_framework.Recommenders.DataIO import DataIO
from recsys_framework.Utils.conf_logging import get_logger

from conferences.cikm.cfgan.our_implementation.constants import CFGANMode, CFGANMaskType
from conferences.cikm.cfgan.our_implementation.models.v1_compat.CFGANModel import CFGANModel
from conferences.cikm.cfgan.our_implementation.parameters import CFGANHyperParameters

logger = get_logger(__name__)


class CFGANRecommender(BaseRecommender):  # type: ignore
    """A TopK recommender backed by a CFGAN.

    Because CFGAN is a conditioned GAN, we need the condition vector to generate the item
    weights. In the CFGAN case, the condition vector is the user's interactions.

    In CFGAN, the generator creates *item weights* instead of interactions (ratings or
    implicit). Based on that, the item scores are simply the weights generated by the
    generator after we pass the condition vector.
    """

    RECOMMENDER_NAME = "CFGANRecommender"

    def __init__(
        self,
        urm_train: sp.csr_matrix,
        num_training_item_weights_to_save: int = 0,
    ):
        super().__init__(urm_train)

        self.model: Optional[CFGANModel] = None
        self.hyper_parameters: Optional[CFGANHyperParameters] = None
        self.item_weights: Optional[np.ndarray] = None
        self.num_training_item_weights_to_save = num_training_item_weights_to_save

    @staticmethod
    def get_recommender_name(
        cfgan_mode: CFGANMode,
        cfgan_mask_type: CFGANMaskType,
        **kwargs,
    ) -> str:
        return (
            f"{CFGANRecommender.RECOMMENDER_NAME}_"
            f"{cfgan_mode.value}_"
            f"{cfgan_mask_type.value}"
        )

    def _compute_item_score(
            self,
            user_id_array: np.ndarray,
            items_to_compute: Optional[List[int]] = None
    ) -> np.ndarray:
        if self.item_weights is None:
            raise ValueError("Model has not been fitted, thus cannot recommend.")

        num_users = user_id_array.shape[0]

        if items_to_compute is None:
            return self.item_weights[user_id_array, :]

        item_scores = -np.ones((num_users, self.n_items), dtype=np.float32) * np.inf
        item_scores[:, items_to_compute] = self.item_weights[user_id_array, items_to_compute]
        return item_scores

    def save_model(
            self,
            folder_path: str,
            file_name: Optional[str] = None
    ) -> None:
        if file_name is None:
            file_name = self.RECOMMENDER_NAME

        if self.model is not None:
            self.model.save_model(
                folder_path=folder_path,
                file_name=file_name,
            )

        data_io = DataIO(
            folder_path=folder_path
        )
        data_io.save_data(
            file_name=file_name,
            data_dict_to_save={
                "item_weights": self.item_weights,
                "hyper_parameters": attr.asdict(self.hyper_parameters),
                "num_training_item_weights_to_save": self.num_training_item_weights_to_save,
            }
        )

    def load_model(
            self,
            folder_path: str,
            file_name: Optional[str] = None
    ) -> None:
        if file_name is None:
            file_name = self.RECOMMENDER_NAME

        data_io = DataIO(
            folder_path=folder_path
        )
        data_dict = data_io.load_data(
            file_name=file_name
        )

        self.hyper_parameters = CFGANHyperParameters(
            **data_dict["hyper_parameters"]
        )
        self.item_weights = data_dict.get(
            "item_weights"
        )
        self.num_training_item_weights_to_save = data_dict.get(
            "num_training_item_weights_to_save",
            0
        )

        self.model = CFGANModel(
            urm_train=self.URM_train,
            hyper_parameters=self.hyper_parameters,
            num_training_item_weights_to_save=self.num_training_item_weights_to_save,
            initialize_model=False,
        )
        self.model.load_model(
            folder_path=folder_path,
            file_name=file_name,
        )

    def fit(
            self,
            **kwargs: Dict[str, Any]
    ) -> None:

        try:
            self.hyper_parameters = CFGANHyperParameters(**kwargs)
        except TypeError as e:
            logger.exception(f"Kwargs {kwargs} could not be converted into CFGANHyperParameters")
            raise e

        self.RECOMMENDER_NAME = self.get_recommender_name(
            cfgan_mode=self.hyper_parameters.mode,
            cfgan_mask_type=self.hyper_parameters.mask_type,
        )

        self.model = CFGANModel(
            urm_train=self.URM_train,
            hyper_parameters=self.hyper_parameters,
            num_training_item_weights_to_save=self.num_training_item_weights_to_save,
            initialize_model=True,
        )

        self.model.run_all_epochs()
        self.item_weights = self.model.get_item_weights(
            urm=None
        )
